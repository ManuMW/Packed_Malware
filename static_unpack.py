import pathlib
import re
from os import listdir
from os.path import isfile, join
from typing import List
import os
import sys
import threading

import pefile
import peutils
from unipacker.core import Sample, UnpackerEngine, SimpleClient

import argparse

file = r'C:\Users\ASUS\Downloads\New_test\packed'



def parse_instructions(file_path):
    instructions = []
    with open(file_path) as f:
        for line in f:
            if "0x" in line:
                instruction = line.strip("\t").split()[1]
                if instruction:
                    instructions.append(instruction.strip("b'"))

    return instructions


def is_sequence_present(instructions: List, pattern_list: List):
    instructions_str = ":".join(instructions)
    patterns_str = ":".join(pattern_list)
    return re.match(f".*{patterns_str}.*", instructions_str) is not None


def _unpack(t, unpacked="unpacked.exe"):
    file = t
    sample = Sample(file)
    event = threading.Event()
    client = SimpleClient(event)
    # heartbeat = RepeatedTimer(120, print, "- still running -", file=sys.stderr)

    engine = UnpackerEngine(sample, unpacked)
    engine.register_client(client)
    # heartbeat.start()
    threading.Thread(target=engine.emu).start()
    event.wait()
    # heartbeat.stop()
    engine.stop()
    assert os.path.exists(unpacked)
    assert not os.path.exists(sample.unpacker.dumper.brokenimport_dump_file)
    if os.path.exists(unpacked):
        return file
    else:
        return file


def unipack():
    sample = Sample(file)
    unpack_path = r'C:\Users\ASUS\Downloads\unpacked\unpacked.exe'

    engine = UnpackerEngine(sample, unpack_path)
    engine.init_uc()


def unpack_files(directory):
    print(directory)
    if directory is None:
        return

    files = os.listdir(directory)
    for file_name in files:
        file_path = str(pathlib.Path(directory).joinpath(file_name))
        file_path2 = rf'C:\Users\ASUS\Downloads\Packed_Files_malware\Unpacked\{file_name}'
        unpacked_file_path = f"{file_path2}-unpacked"
        _unpack(file_path, unpacked_file_path)
        print(f"Unpacked file {file_path} to {unpacked_file_path}")

def process(args):
    unpack_files(args.directory)


if __name__ == '__main__':

    parser = argparse.ArgumentParser(description='Input a directory with files')
    parser.add_argument('-d',
                        '--directory',
                        help="File path",
                        required=True)
    parser.set_defaults(func=process)

    args = parser.parse_args()
    try:
        args.func(args)
    except AttributeError:
        parser.print_help()
        parser.exit()

    #
    debug_Path = "C:/Users/ASUS/Downloads/Packed_Files_malware/Unpacked"
    #debugDir = os.listdir(debug_Path)
    for path1, dirs, file7 in os.walk(debug_Path):
        for f in file7:
            debug_File = os.path.join(path1, f)

            signatures = peutils.SignatureDatabase(r'C:\Users\ASUS\PycharmProjects\Packed Malware\userdb.txt')
            my_file = os.path.abspath(debug_File)
            pe = pefile.PE(my_file)
            print("Sections: ", end='')
            print("\t\tEntropy\n")
            for sect in pe.sections:
                print("%17s" % (sect.Name).decode('utf-8'), end='')
                print(("\t%5.2f" % sect.get_entropy()))
                if sect.get_entropy() > 6.8:
                    print("Packed section (Maybe) ""%17s" % (sect.Name).decode('utf-8'))
            matches = signatures.match(pe, ep_only=True)
            print(matches)
            print("The entry point of the file is: ", pe.OPTIONAL_HEADER.AddressOfEntryPoint)

            if matches == None:
                print("Need to upgrade the signature database")

    ######################

            print("Machine : " + hex(pe.FILE_HEADER.Machine))

            # Check if it is a 32-bit or 64-bit binary
            if hex(pe.FILE_HEADER.Machine) == '0x14c':
                print("This is a 32-bit binary")
            else:
                print("This is a 64-bit binary")

            print("TimeDateStamp : " + pe.FILE_HEADER.dump_dict()['TimeDateStamp']['Value'].split('[')[1][:-1])

            print("NumberOfSections : " + hex(pe.FILE_HEADER.NumberOfSections))

            print("Characteristics flags : " + hex(pe.FILE_HEADER.Characteristics))

            ####################

            pe.parse_data_directories()

            orgStdout = sys.stdout
            f = open(rf'{debug_File}.txt', 'w')
            sys.stdout = f
            # for entry in pe.DIRECTORY_ENTRY_IMPORT:
            #
            #     print(entry.dll)
            #     for imp in entry.imports:
            #         print('\t', hex(imp.address), imp.name)
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    print(entry.dll)
                    for imp in entry.imports:
                        print('\t', hex(imp.address), imp.name, imp.ordinal, entry.dll)

            sys.stdout = orgStdout
            f.close()

            # searchDebugInfo()
            print('')
            sequence = ["IsDebuggerPresent"]
            instructions_list = parse_instructions("test_file.txt")
            # print(is_sequence_present(instructions_list, sequence))

            if is_sequence_present(instructions_list, sequence) == None:
                print("No anti Debugger present")
            else:
                print("Anti debugger is present")
