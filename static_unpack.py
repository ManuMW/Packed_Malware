import difflib
import re
from typing import List
import os
import sys
import threading
from difflib import Differ
from tempfile import TemporaryDirectory

import pefile
import peutils
from unipacker.core import Sample, UnpackerEngine, SimpleClient
from unipacker.utils import RepeatedTimer


import unipacker
from unipacker.unpackers import DefaultUnpacker, identifypacker, get_unpacker, \
    AutomaticDefaultUnpacker

file = r'C:\Users\ASUS\Downloads\New_test\packed'

def parse_instructions(file_path):
    instructions = []
    with open(file_path) as f:
        for line in f:
            if "0x" in line:
                instruction = line.strip("\t").split()[1]
                if instruction:
                    instructions.append(instruction.strip("b'"))

    return instructions


def is_sequence_present(instructions: List, pattern_list: List):
    instructions_str = ":".join(instructions)
    patterns_str = ":".join(pattern_list)
    return re.match(f".*{patterns_str}.*", instructions_str) is not None
# def searchDebugInfo():
#     string1 = 'IsDebuggerPresent'
#     string2 = 'IsDebuggerPresent2' | 'jahsfja' | asjfgasf
#
#     # opening a text file
#     file1 = open(r"C:\Users\ASUS\Downloads\unpacked\output.txt", "r")
#
#     # setting flag and index to 0
#     flag = 0
#     index = 0
#
#     # Loop through the file line by line
#     for line in file1:
#         index += 1
#
#         # checking string is present in line or not
#         if string1 in line:
#
#             flag = 1
#             break
#
#     # checking condition for string found or not
#     if flag == 0:
#         print('Anti Debugger', string1, 'Not Found')
#     else:
#         print('API Calls made are')
#         print(string1)
#         #print('Anti Debugger found', string1, 'Found In Line', index)


    # closing text file
    file1.close()


def _unpack(t):
    file = t
    unpacked = r"C:\Users\ASUS\Downloads\unpacked\unpacked.exe"
    sample = Sample(file)
    event = threading.Event()
    client = SimpleClient(event)
    # heartbeat = RepeatedTimer(120, print, "- still running -", file=sys.stderr)

    engine = UnpackerEngine(sample, unpacked)
    engine.register_client(client)
    # heartbeat.start()
    threading.Thread(target=engine.emu).start()
    event.wait()
    # heartbeat.stop()
    engine.stop()
    assert os.path.exists(unpacked)
    assert not os.path.exists(sample.unpacker.dumper.brokenimport_dump_file)
    if os.path.exists(unpacked):
        return file
    else:
        return file

def unipack():
    sample = Sample(file)
    unpack_path = r'C:\Users\ASUS\Downloads\unpacked\unpacked.exe'

    engine = UnpackerEngine(sample, unpack_path)
    engine.init_uc()


if __name__ == '__main__':
    _unpack(file)
    debugPath = r'C:\Users\ASUS\Downloads\unpacked\unpacked.exe'
    signatures = peutils.SignatureDatabase(r'C:\Users\ASUS\PycharmProjects\Packed Malware\userdb.txt')
    my_file = os.path.abspath(debugPath)
    pe = pefile.PE(my_file)
    print("Sections: ", end='')
    print("\t\tEntropy\n")
    for sect in pe.sections:
        print("%17s" % (sect.Name).decode('utf-8'), end='')
        print(("\t%5.2f" % sect.get_entropy()))
        if sect.get_entropy() > 6.8:
            print("Packed section (Maybe) ""%17s"% (sect.Name).decode('utf-8'))
    matches = signatures.match(pe, ep_only=True)
    print(matches)
    print("The entry point of the file is: ",pe.OPTIONAL_HEADER.AddressOfEntryPoint)

    if matches == None:
        print("Need to upgrade the signature database")

######################

    print("Machine : " + hex(pe.FILE_HEADER.Machine))

    # Check if it is a 32-bit or 64-bit binary
    if hex(pe.FILE_HEADER.Machine) == '0x14c':
        print("This is a 32-bit binary")
    else:
        print("This is a 64-bit binary")

    print("TimeDateStamp : " + pe.FILE_HEADER.dump_dict()['TimeDateStamp']['Value'].split('[')[1][:-1])

    print("NumberOfSections : " + hex(pe.FILE_HEADER.NumberOfSections))

    print("Characteristics flags : " + hex(pe.FILE_HEADER.Characteristics))


    ####################
    # If the PE file was loaded using the fast_load=True argument, we will need to parse the data directories:
    pe.parse_data_directories()

    orgStdout = sys.stdout
    f = open(r'C:\Users\ASUS\Downloads\unpacked\output.txt', 'w')
    sys.stdout = f
    for entry in pe.DIRECTORY_ENTRY_IMPORT:

        print(entry.dll)
        for imp in entry.imports:
            print('\t', hex(imp.address), imp.name)

    sys.stdout = orgStdout
    f.close()

    # searchDebugInfo()
    print('')
    print('')
    sequence = ["IsDebuggerPresent"]
    instructions_list = parse_instructions("test_file.txt")
    # print(is_sequence_present(instructions_list, sequence))

    if is_sequence_present(instructions_list, sequence) == None:
        print("No anti Debugger present")
    else:
        print("Anti debugger is present")
