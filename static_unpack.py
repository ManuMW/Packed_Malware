import difflib
import os
import sys
import threading
from difflib import Differ
from tempfile import TemporaryDirectory

import pefile
import peutils
from unipacker.core import Sample, UnpackerEngine, SimpleClient
from unipacker.utils import RepeatedTimer


import unipacker
from unipacker.unpackers import DefaultUnpacker, identifypacker, get_unpacker, \
    AutomaticDefaultUnpacker

file = r'C:\Users\ASUS\Downloads\New_test\packed'

def searchDebugInfo():
    string1 = 'IsDebuggerPresent'

    # opening a text file
    file1 = open(r"C:\Users\ASUS\Downloads\unpacked\output.txt", "r")

    # setting flag and index to 0
    flag = 0
    index = 0

    # Loop through the file line by line
    for line in file1:
        index += 1

        # checking string is present in line or not
        if string1 in line:

            flag = 1
            break

    # checking condition for string found or not
    if flag == 0:
        print('Anti Debugger', string1, 'Not Found')
    else:
        print('API Calls made are')
        print(string1)
        #print('Anti Debugger found', string1, 'Found In Line', index)


    # closing text file
    file1.close()


def _unpack(t):
    file = t
    unpacked = r"C:\Users\ASUS\Downloads\unpacked\unpacked.exe"
    sample = Sample(file)
    event = threading.Event()
    client = SimpleClient(event)
    # heartbeat = RepeatedTimer(120, print, "- still running -", file=sys.stderr)

    engine = UnpackerEngine(sample, unpacked)
    engine.register_client(client)
    # heartbeat.start()
    threading.Thread(target=engine.emu).start()
    event.wait()
    # heartbeat.stop()
    engine.stop()
    assert os.path.exists(unpacked)
    assert not os.path.exists(sample.unpacker.dumper.brokenimport_dump_file)
    if os.path.exists(unpacked):
        return file
    else:
        return file

def unipack():
    sample = Sample(file)
    unpack_path = r'C:\Users\ASUS\Downloads\unpacked\unpacked.exe'

    engine = UnpackerEngine(sample, unpack_path)
    engine.init_uc()


if __name__ == '__main__':
    _unpack(file)
    debugPath = r'C:\Users\ASUS\Downloads\unpacked\unpacked.exe'
    signatures = peutils.SignatureDatabase(r'C:\Users\ASUS\PycharmProjects\Packed Malware\userdb.txt')
    my_file = os.path.abspath(debugPath)
    pe = pefile.PE(my_file)
    print("Sections: ", end='')
    print("\t\tEntropy\n")
    for sect in pe.sections:
        print("%17s" % (sect.Name).decode('utf-8'), end='')
        print(("\t%5.2f" % sect.get_entropy()))
        if sect.get_entropy() > 6.8:
            print("Packed section (Maybe) ""%17s"% (sect.Name).decode('utf-8'))
    matches = signatures.match(pe, ep_only=True)
    print(matches)
    print("The entry point of the file is: ",pe.OPTIONAL_HEADER.AddressOfEntryPoint)

    if matches == None:
        print("Need to upgrade the signature database")

######################

    print("Machine : " + hex(pe.FILE_HEADER.Machine))

    # Check if it is a 32-bit or 64-bit binary
    if hex(pe.FILE_HEADER.Machine) == '0x14c':
        print("This is a 32-bit binary")
    else:
        print("This is a 64-bit binary")

    print("TimeDateStamp : " + pe.FILE_HEADER.dump_dict()['TimeDateStamp']['Value'].split('[')[1][:-1])

    print("NumberOfSections : " + hex(pe.FILE_HEADER.NumberOfSections))

    print("Characteristics flags : " + hex(pe.FILE_HEADER.Characteristics))


    ####################
    # If the PE file was loaded using the fast_load=True argument, we will need to parse the data directories:
    pe.parse_data_directories()

    orgStdout = sys.stdout
    f = open(r'C:\Users\ASUS\Downloads\unpacked\output.txt', 'w')
    sys.stdout = f
    for entry in pe.DIRECTORY_ENTRY_IMPORT:

        print(entry.dll)
        for imp in entry.imports:
            print('\t', hex(imp.address), imp.name)

    sys.stdout = orgStdout
    f.close()

    searchDebugInfo()
