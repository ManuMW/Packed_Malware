import difflib
import re
from typing import List
import os
import sys
import threading
from difflib import Differ
from tempfile import TemporaryDirectory

import pefile
import peutils
from unipacker.core import Sample, UnpackerEngine, SimpleClient
from unipacker.utils import RepeatedTimer


import unipacker
from unipacker.unpackers import DefaultUnpacker, identifypacker, get_unpacker, \
    AutomaticDefaultUnpacker

file = r'C:\Users\ASUS\Downloads\New_test\packed'

def parse_instructions(file_path):
    instructions = []
    with open(file_path) as f:
        for line in f:
            if "0x" in line:
                instruction = line.strip("\t").split()[1]
                if instruction:
                    instructions.append(instruction.strip("b'"))

    return instructions


def is_sequence_present(instructions: List, pattern_list: List):
    instructions_str = ":".join(instructions)
    patterns_str = ":".join(pattern_list)
    return re.match(f".*{patterns_str}.*", instructions_str) is not None



def _unpack(t):
    file = t
    unpacked = r"C:\Users\ASUS\Downloads\unpacked\unpacked.exe"
    sample = Sample(file)
    event = threading.Event()
    client = SimpleClient(event)
    # heartbeat = RepeatedTimer(120, print, "- still running -", file=sys.stderr)

    engine = UnpackerEngine(sample, unpacked)
    engine.register_client(client)
    # heartbeat.start()
    threading.Thread(target=engine.emu).start()
    event.wait()
    # heartbeat.stop()
    engine.stop()
    assert os.path.exists(unpacked)
    assert not os.path.exists(sample.unpacker.dumper.brokenimport_dump_file)
    if os.path.exists(unpacked):
        return file
    else:
        return file

def unipack():
    sample = Sample(file)
    unpack_path = r'C:\Users\ASUS\Downloads\unpacked\unpacked.exe'

    engine = UnpackerEngine(sample, unpack_path)
    engine.init_uc()


if __name__ == '__main__':
    _unpack(file)
    debugPath = r'C:\Users\ASUS\Downloads\unpacked\unpacked.exe'
    signatures = peutils.SignatureDatabase(r'C:\Users\ASUS\PycharmProjects\Packed Malware\userdb.txt')
    my_file = os.path.abspath(debugPath)
    pe = pefile.PE(my_file)
    print("Sections: ", end='')
    print("\t\tEntropy\n")
    for sect in pe.sections:
        print("%17s" % (sect.Name).decode('utf-8'), end='')
        print(("\t%5.2f" % sect.get_entropy()))
        if sect.get_entropy() > 6.8:
            print("Packed section (Maybe) ""%17s"% (sect.Name).decode('utf-8'))
    matches = signatures.match(pe, ep_only=True)
    print(matches)
    print("The entry point of the file is: ",pe.OPTIONAL_HEADER.AddressOfEntryPoint)

    if matches == None:
        print("Need to upgrade the signature database")

######################

    print("Machine : " + hex(pe.FILE_HEADER.Machine))

    # Check if it is a 32-bit or 64-bit binary
    if hex(pe.FILE_HEADER.Machine) == '0x14c':
        print("This is a 32-bit binary")
    else:
        print("This is a 64-bit binary")

    print("TimeDateStamp : " + pe.FILE_HEADER.dump_dict()['TimeDateStamp']['Value'].split('[')[1][:-1])

    print("NumberOfSections : " + hex(pe.FILE_HEADER.NumberOfSections))

    print("Characteristics flags : " + hex(pe.FILE_HEADER.Characteristics))


    ####################

    pe.parse_data_directories()

    orgStdout = sys.stdout
    f = open(r'C:\Users\ASUS\Downloads\unpacked\output.txt', 'w')
    sys.stdout = f
    for entry in pe.DIRECTORY_ENTRY_IMPORT:

        print(entry.dll)
        for imp in entry.imports:
            print('\t', hex(imp.address), imp.name)

    sys.stdout = orgStdout
    f.close()

    # searchDebugInfo()
    print('')
    sequence = ["IsDebuggerPresent"]
    instructions_list = parse_instructions("test_file.txt")
    # print(is_sequence_present(instructions_list, sequence))

    if is_sequence_present(instructions_list, sequence) == None:
        print("No anti Debugger present")
    else:
        print("Anti debugger is present")
